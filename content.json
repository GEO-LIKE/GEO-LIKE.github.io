{"meta":{"title":"不为不知难已","subtitle":"世无难事，不为不知难已。","description":"纸上得来终觉浅，不为不知难已。","author":"GEO-LIKE","url":"http://geo-like.github.io"},"pages":[{"title":"tags","date":"2017-11-25T06:19:22.000Z","updated":"2017-11-25T06:24:58.082Z","comments":true,"path":"tags/index.html","permalink":"http://geo-like.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-11-25T06:26:10.000Z","updated":"2017-11-25T06:28:45.461Z","comments":false,"path":"categories/index.html","permalink":"http://geo-like.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"openCV：滑动条之setTrackbarPos与createTrackbar","slug":"openCV：滑动条之setTrackbarPos与createTrackbar","date":"2017-12-01T07:19:33.000Z","updated":"2017-12-01T07:23:50.971Z","comments":true,"path":"blog/2017/12/01/openCV：滑动条之setTrackbarPos与createTrackbar/","link":"","permalink":"http://geo-like.github.io/blog/2017/12/01/openCV：滑动条之setTrackbarPos与createTrackbar/","excerpt":"滑动条（trackbar）创建滑动条（createTrackbar）openCV提供createTrackbar指定图像窗口创建一个指定名称和范围的滑动条，使用户能够滑动调整输入，然后根据输入值执行程序。还提供了getTrackbarPos和setTrackbarPos以获取和修改bar的当前值。","text":"滑动条（trackbar）创建滑动条（createTrackbar）openCV提供createTrackbar指定图像窗口创建一个指定名称和范围的滑动条，使用户能够滑动调整输入，然后根据输入值执行程序。还提供了getTrackbarPos和setTrackbarPos以获取和修改bar的当前值。12// C++ codeint createTrackbar(const string&amp; trackbarname, const string&amp; winname, int* value, int count, TrackbarCallback onChange=0, void*userdata=0) Parameters: trackbarname：创建的滑动条名。 winname：滑动条的父窗体名。 value：滑动条当前值。 count：允许的最大值，最小值为0。 onChange：回调函数，当滑动条位置发生变化时，调用此函数。函数形如void Foo(int,void*);，第一个是位置值，第二个是userdata userdata：可以被传递给回调函数，可以在没有全局位置变量时起作用。 获取当前值（getTrackbarPos）1int getTrackbarPos(const String&amp; trackbarname, const String&amp; winname) Parameters: trackbarname：滑动条名称。 winname：窗口名称 设置滑动条位置（setTrackbarPos）1void setTrackbarPos(const String&amp; trackbarname, const String&amp; winname, int pos) Parameters: trackbarname：滑动条名称。 winname：窗口名称。 pos：新位置。 测试代码代码功能描述： 通过调整滑动条的位置可以调整视频的帧位； ”r“键播放视频； ”s“键每按一次切换一帧； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//code from &quot;Learning OpenCV 3&quot;#include&lt;opencv2\\highgui.hpp&gt;#include&lt;opencv2\\imgproc.hpp&gt;#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int g_slider_position = 0;int g_run = 1, g_dontset = 0;cv::VideoCapture g_cap;void onTrackbarSlide(int pos, void *) &#123; g_cap.set(cv::CAP_PROP_POS_FRAMES, pos); if (!g_dontset) g_run = 1; g_dontset = 0;&#125;int main() &#123; string winName = &quot;Example2-4&quot;; string trackName = &quot;Position&quot;; cv::namedWindow(winName, cv::WINDOW_AUTOSIZE); g_cap.open(string(&quot;C:\\\\Users\\\\LIKE\\\\Videos\\\\Bad Apple.mp4&quot;)); int frames = (int)g_cap.get(cv::CAP_PROP_FRAME_COUNT); int tmpw = (int)g_cap.get(cv::CAP_PROP_FRAME_WIDTH); int tmph = (int)g_cap.get(cv::CAP_PROP_FRAME_HEIGHT); cout &lt;&lt; &quot;Video has &quot; &lt;&lt; frames &lt;&lt; &quot; frames of dimensions(&quot; &lt;&lt; tmpw &lt;&lt; &quot;,&quot; &lt;&lt; tmph &lt;&lt; &quot;).&quot; &lt;&lt; endl; cv::createTrackbar(trackName, winName, &amp;g_slider_position, frames, onTrackbarSlide); cv::Mat frame; for (;;) &#123; if (g_run != 0) &#123; g_cap &gt;&gt; frame; if (frame.empty()) break; int current_pos = (int)g_cap.get(cv::CAP_PROP_POS_FRAMES); g_dontset = 1; cv::setTrackbarPos(trackName, winName, current_pos); current_pos = cv::getTrackbarPos(trackName, winName); cout &lt;&lt; current_pos &lt;&lt; endl; cv::imshow(winName, frame); g_run -= 1; &#125; char c = (char)cv::waitKey(10); if (c == &apos;s&apos;) &#123; g_run = 1; cout &lt;&lt; &quot;Single Step, run = &quot; &lt;&lt; g_run &lt;&lt; endl; &#125; if (c == &apos;r&apos;) &#123; g_run = -1; cout &lt;&lt; &quot;Run_mode, run = &quot; &lt;&lt; g_run &lt;&lt; endl; &#125; if (c == 27) break; &#125; return(0);&#125;","categories":[],"tags":[{"name":"滑动条","slug":"滑动条","permalink":"http://geo-like.github.io/tags/滑动条/"},{"name":"openCV","slug":"openCV","permalink":"http://geo-like.github.io/tags/openCV/"},{"name":"setTrackbarPos","slug":"setTrackbarPos","permalink":"http://geo-like.github.io/tags/setTrackbarPos/"},{"name":"createTrackbar","slug":"createTrackbar","permalink":"http://geo-like.github.io/tags/createTrackbar/"}]},{"title":"ArcMap欧氏距离工具提取图像骨架线","slug":"ArcMap欧氏距离工具提取图像骨架线","date":"2017-11-29T00:42:07.000Z","updated":"2017-11-29T00:50:23.530Z","comments":true,"path":"blog/2017/11/29/ArcMap欧氏距离工具提取图像骨架线/","link":"","permalink":"http://geo-like.github.io/blog/2017/11/29/ArcMap欧氏距离工具提取图像骨架线/","excerpt":"图像骨架线(Morphological skeleton)图像骨架线在wiki中有两个术语，分别是Morphological skeleton和Topological skeleton。 形态骨架线（Morphological skeleton）在数字图像处理中，形态骨架是通过形态学算子计算的形状或二值图像的骨架（或中轴）表示。形态骨架有两种：那些通过形态开口定义的，可以重建原始形状的开口， 那些通过hit-or-miss变换来计算的，它保留了形状的拓扑结构。（谷歌翻译） 拓扑骨架线（Topological skeleton）在形状分析中，形状的骨架（或拓扑骨架）是与其边界等距的形状的薄形。骨架通常强调形状的几何和拓扑性质，如连通性，拓扑结构，长度，方向和宽度。连同它的点到形状边界的距离，骨架还可以作为形状的表示（它们包含重建形状所需的所有信息）。（谷歌翻译）","text":"图像骨架线(Morphological skeleton)图像骨架线在wiki中有两个术语，分别是Morphological skeleton和Topological skeleton。 形态骨架线（Morphological skeleton）在数字图像处理中，形态骨架是通过形态学算子计算的形状或二值图像的骨架（或中轴）表示。形态骨架有两种：那些通过形态开口定义的，可以重建原始形状的开口， 那些通过hit-or-miss变换来计算的，它保留了形状的拓扑结构。（谷歌翻译） 拓扑骨架线（Topological skeleton）在形状分析中，形状的骨架（或拓扑骨架）是与其边界等距的形状的薄形。骨架通常强调形状的几何和拓扑性质，如连通性，拓扑结构，长度，方向和宽度。连同它的点到形状边界的距离，骨架还可以作为形状的表示（它们包含重建形状所需的所有信息）。（谷歌翻译） 骨架线提取方法根据上面图像骨架线的定义，即骨架线到边界等距，可知骨架线是与边界距离相等的点的集合。作为专业的GIS人员，很容易就想到了由边界向内部做缓冲区，就可以求出中心线，也可以提出骨架线。这里生成的缓冲区必须是连续的缓冲区，所以不能使用矢量缓冲区的Buffer，而应该使用欧氏距离向图形内部做缓冲区，原理和openCV中的距离变换一致。 欧式距离直角坐标系中两点间的直线距离：$$ dist = \\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}$$ ArcMap中的欧氏距离 Euclidean Distance gives the distance from each cell in the raster to the closest source. Example of usage: What is the distance to the closest town? 实验1数据是随意生成的一个两个矩形 步骤1. 图像取反画一个更大的矩形包裹住这两个小矩形，然后使用这两个小矩形在上面抠出两个洞。有很多方法可以抠这个洞，不献丑我就不写了，如下图： 2. 使用欧氏距离生成缓冲区/距离场1[Spatial Analysis]-&gt;[Distance]-&gt;[Euclidean Distance] 3. 提取骨架线这一步主要是提取距离场中的突变处，使用坡度或者曲率都可。下图因为宽度只有一两个像素而显示不出来，其实是连续的线。最后结果要重分类，将非骨架线区域转换成NoData。1[Spatial Analysis]-&gt;[Surface]-&gt;[Slope] or [Curvature] 4. 转换成矢量线 实验2数据 欧氏距离 骨架线重分类的时候，因为阈值设置的不好，有断线，选取一个合适的阈值就可以处理断线了。 结果分析是不是很像山脊线？","categories":[],"tags":[{"name":"图像骨架线","slug":"图像骨架线","permalink":"http://geo-like.github.io/tags/图像骨架线/"},{"name":"ArcMap","slug":"ArcMap","permalink":"http://geo-like.github.io/tags/ArcMap/"},{"name":"GIS","slug":"GIS","permalink":"http://geo-like.github.io/tags/GIS/"},{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://geo-like.github.io/tags/ArcGIS/"}]},{"title":"C++版openCV的waitKey(0)失效的解决办法","slug":"Cpp版openCV-waitKey-0-失效的解决办法-1","date":"2017-11-28T11:02:15.000Z","updated":"2017-11-28T11:26:26.276Z","comments":true,"path":"blog/2017/11/28/Cpp版openCV-waitKey-0-失效的解决办法-1/","link":"","permalink":"http://geo-like.github.io/blog/2017/11/28/Cpp版openCV-waitKey-0-失效的解决办法-1/","excerpt":"问题描述今天遇到了一个问题，使用opencv读取一张图像并显示，Build然后F5。不知未何，图像窗口一闪而过。明明加上了waitKey(0)呀，至少应该等我按键才会结束的嘛，Ctrl + F5依然不行。为何会这样？","text":"问题描述今天遇到了一个问题，使用opencv读取一张图像并显示，Build然后F5。不知未何，图像窗口一闪而过。明明加上了waitKey(0)呀，至少应该等我按键才会结束的嘛，Ctrl + F5依然不行。为何会这样？环境配置123windows10visual studio 2015openCV3.3.1 测试代码12345678#include&lt;opencv2\\opencv.hpp&gt;using namespace cv;int main() &#123; Mat image = imread(&quot;c:\\\\users\\\\like\\\\pictures\\\\图片2.tif&quot;); imshow(&quot;original&quot;, image); waitKey(0); return 0;&#125; 解决办法按照autocyz的文章:opencv中waitkey(0)不起作用，加上system(“pause”)也没有解决问题。窗口没有消失，也没有显示图像内容。但是图像弹窗的标题是乱码的，命令行提示size&lt;0，推测可能是代码文件的编码方式有问题导致没有找到图像，不是utf-8，不属于编译器默认的文件编码格式。 使用notepad++打开test.cpp，点击菜单中【编码】，发现该文件的编码方式是【UTF-8无BOM格式编码】，点击下面的【UTF-8格式编码】，即刻修改为正常的utf-8的格式。可能代码中的中文需要重新输入才能解决问题。 python中可能出现的问题抛开代码格式问题不谈，opencv显示图像的窗口可能卡死，这是因为没有加上waitKey()导致的。 StackOverflow上也有人发布了waitKey不起作用的问题：Opencv python. WaitKey don’t respond? 123456import cv2img = cv2.imread(&apos;347620923614738322_233985812.jpg&apos;)cv2.namedWindow(&quot;window&quot;)cv2.imshow(&quot;window&quot;, img)cv2.waitKey(0) 给出的解决方案是加上destoryAllWindows()1234567891011121314151617181920# -*- coding: utf-8 -*-# Objectif : découvrir le fonctionnement d&apos;opencv-python# http://opencv-python-tutroals.readthedocs.org/en/latest/index.htmlimport numpy as npimport cv2# Load an color image in grayscaleimg = cv2.imread(&apos;Lena.tiff&apos;,0)WINDOW_NAME = &apos;Image de Lena&apos;cv2.namedWindow(WINDOW_NAME, cv2.CV_WINDOW_AUTOSIZE)cv2.startWindowThread()# Display an imagecv2.imshow(WINDOW_NAME,img)cv2.waitKey(0)cv2.destroyAllWindows()","categories":[{"name":"openCV","slug":"openCV","permalink":"http://geo-like.github.io/categories/openCV/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://geo-like.github.io/tags/openCV/"}]},{"title":"Welcome To My Blog","slug":"Welcome-To-My-Blog","date":"2017-11-25T14:50:58.000Z","updated":"2017-11-25T07:37:28.775Z","comments":true,"path":"blog/2017/11/25/Welcome-To-My-Blog/","link":"","permalink":"http://geo-like.github.io/blog/2017/11/25/Welcome-To-My-Blog/","excerpt":"","text":"欢迎来访建立这个博客，目的只在于记录过程、总结知识。过去的东西没有留下什么，相当于什么都没有，这次就是重新开始吧，积累、升华！","categories":[],"tags":[{"name":"Author Tag","slug":"Author-Tag","permalink":"http://geo-like.github.io/tags/Author-Tag/"}]},{"title":"openCV中的查找表","slug":"Test-My-Site","date":"2017-11-25T07:30:14.000Z","updated":"2017-11-25T07:37:06.583Z","comments":true,"path":"blog/2017/11/25/Test-My-Site/","link":"","permalink":"http://geo-like.github.io/blog/2017/11/25/Test-My-Site/","excerpt":"openCV中的查找表ref：http://blog.csdn.net/u010963435/article/details/78569714首次见识LUT是在openCV官方文档:How to scan images, lookup tables and time measurement with OpenCV文章中通过一个图像色彩压缩的例子，对比LUT与其他三种图像遍历方法的时间耗费，表明LUT具有快速遍历图像的能力。","text":"openCV中的查找表ref：http://blog.csdn.net/u010963435/article/details/78569714首次见识LUT是在openCV官方文档:How to scan images, lookup tables and time measurement with OpenCV文章中通过一个图像色彩压缩的例子，对比LUT与其他三种图像遍历方法的时间耗费，表明LUT具有快速遍历图像的能力。从数学上来看查找表是一个简单的一对一或多对一的函数，定义了如何将像素转换为新的值。从数据的组织关系上来看，查找表是一维或多维的数组，存储了不同输入值所对应的输出值。查找表在图像处理中主要用于像素的点运算，尤其是像素之间无位置相关性的操作中，如：图像色彩空间压缩、图像取反、图像分割，直方图均衡化等仅需要考虑像素值的应用。当需要对图像应用窗口运算等与像素位置相关的操作时，就不能使用查找表。(修改自http://www.voidcn.com/article/p-dypyzpta-bgz.html) 查找表使用赋值操作取代计算操作来节省时间耗费，仅需一次遍历就能完成操作任务。 123456789101112 uchar table[256]; for (int i = 0; i &lt; 256; ++i) table[i] = (uchar)(divideWith * (i/divideWith));··· ··· for( i = 0; i &lt; nRows; ++i) &#123; p = Img.ptr&lt;uchar&gt;(i); for ( j = 0; j &lt; nCols; ++j) &#123; p[j] = table[p[j]]; //这也应该算是一种查找表[映射] &#125; &#125; 在Matlab、Numpy中有一种使用logical/bool 类型的矩阵作为索引，进行批量操作矩阵元素的方法，也可以认为是一种查找表。1234%%@ matlab codea = magic(5);b = ones(5);a(a&gt;b) = 0; %将a&gt;b矩阵元素赋值为0 更多参考：http://blog.csdn.net/jameshater/article/details/50759650","categories":[],"tags":[{"name":"Author Tag","slug":"Author-Tag","permalink":"http://geo-like.github.io/tags/Author-Tag/"},{"name":"Testing","slug":"Testing","permalink":"http://geo-like.github.io/tags/Testing/"}]},{"title":"My New Post","slug":"My-New-Post","date":"2017-11-24T12:27:29.000Z","updated":"2017-11-25T08:33:59.499Z","comments":true,"path":"blog/2017/11/24/My-New-Post/","link":"","permalink":"http://geo-like.github.io/blog/2017/11/24/My-New-Post/","excerpt":"欢迎使用Markdown编辑器写博客本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦：","text":"欢迎使用Markdown编辑器写博客本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦： Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 LaTex数学公式 UML序列图和流程图 离线写博客 导入导出Markdown文件 丰富的快捷键 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考Github. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 定义列表Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如：12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。 块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 这儿. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入","categories":[],"tags":[{"name":"Author Tag","slug":"Author-Tag","permalink":"http://geo-like.github.io/tags/Author-Tag/"},{"name":"Testing","slug":"Testing","permalink":"http://geo-like.github.io/tags/Testing/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-24T12:13:33.027Z","updated":"2017-11-25T07:34:14.128Z","comments":true,"path":"blog/2017/11/24/hello-world/","link":"","permalink":"http://geo-like.github.io/blog/2017/11/24/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Author Tag","slug":"Author-Tag","permalink":"http://geo-like.github.io/tags/Author-Tag/"},{"name":"Testing","slug":"Testing","permalink":"http://geo-like.github.io/tags/Testing/"}]}]}